// def max_subarray(numbers):
//     """Find the largest sum of any contiguous subarray."""
//     best_sum = 0  # or: float('-inf')
//     current_sum = 0
//     for x in numbers:
//         current_sum = max(0, current_sum + x)
//         best_sum = max(best_sum, current_sum)
//     return best_sum



/*

### Caller Saved Registers

**Caller saved registers** are scratch registers.
The **callee** (next function) is **allowed** to scribble (**override**) all over them.
So **if** the **callers** **cares** about the **content** in these registers, the callers **must** **save** them **onto** the **stack**.

[IMPORTANT⚠️]  Caller saved registers in includes

- the **argument registers**: `%rdi, %rsi, %rdx, %rcx, %r8, %r9`
- the **return register**: `%rax`
- `%r10, %r11`

### Callee Saved Registers

**Callee saved registers** are registers that <u>**callee** **must** **restore** before returning</u>.
If the callee uses them, then the callee <u>must restore the original values before returning</u>.

[IMPORTANT⚠️]  Callee saved registers includes: `%rbx, %rbp, %r12, %r13, %r14`
*/




/*

def max_subarray(numbers):
    """Find a contiguous subarray with the largest sum."""
    best_sum = 0  # or: float('-inf')
    best_start = best_end = 0  # or: None
    current_sum = 0
    for current_end, x in enumerate(numbers):
        if current_sum <= 0:
            # Start a new sequence at the current element
            current_start = current_end
            current_sum = x
        else:
            # Extend the existing sequence with the current element
            current_sum += x

        if current_sum > best_sum:
            best_sum = current_sum
            best_start = current_start
            best_end = current_end + 1  # the +1 is to make 'best_end' exclusive

    return best_sum, best_start, best_end



*/


#include <limits.h>
long maxsa(long *array, long size, long **sa_start, long **sa_end) { // TODO Remove Excess Params
  long best_sum = 0;
  long current_sum = 0;
  long *ptr;
  long *end = array + size - 1;

  for (ptr = array; ptr < end; ptr++) {
    long x = *ptr;
     if (0 > current_sum) {
         current_sum = x;
     } else {
         current_sum = current_sum + x;
     }
    if (best_sum < current_sum) {
        best_sum = current_sum;
    }
  }
  return best_sum;
}



# --
Current Status:

rdi = adress of array
rsi = array size

r8 = ptr
r9 = placeholder
r10 = best_sum
r11 = current_sum

rdx = end
rax = result
rcx = ???
rbp = 8,
# --









.pos 0x100
main:
    irmovq $stackEnd, %rsp
    irmovq $array, %rdi           # rdi = address of array i.e. &array[0]
    irmovq $arraySize, %rsi       # rsi = address arraySize
    mrmovq (%rsi), %rsi           # rsi = arraySize
    irmovq $resultStart, %rdx     # rdx = address of sa_start
    irmovq $resultEnd, %rcx       # rcx = address of sa_end
    call   maxSubArray
    irmovq $resultSum, %r8
    rmmovq %rax, (%r8)
    halt

# .pos 0x1000
maxSubArray:

    irmovq $0, %r10         # best_sum = 0
    irmovq $0, %r11         # current_sum = 0

    irmovq $8, %rcx          # rcx = 8
    mulq   %rcx, %rsi        # rsi = offset
    rrmovq %rdi, %rdx        # rdx = array
    addq   %rsi, %rdx        # rdx = array + offset
    subq   %rcx, %rdx        # end = array + offset - 1

    # Init Ptr
    rrmovq %rdi, %r8         # r8 = ptr = &array[0]

L1: # for (ptr = array; ptr <= end; ptr++) {...}

    # TODO ptr < end
    rrmovq %rdx, %r9        # r9 = end
    subq   %r8, %r9         # r9 = end - ptr
    jl     L5               # if end < ptr, exit the loop
    mrmovq (%r8), %r9       # x = *ptr

    irmovq $0, %rcx         # rcx = 0
    rrmovq %r11, %rax       # rax = current_sum
    subq   %rax, %rcx       # if (0 > current_sum)
    jle    L2
    rrmovq %r9, %r11        # current_sum = x
    jmp       L3
L2:
    addq %r11, %r9          # r9 = current_sum + x
    rrmovq %r9, %rdi        # r12 = current_sum + x
    rrmovq %r9, %r11        # current_sum = current_sum + x
L3:
    rrmovq %r10, %r9        # r9 = best_sum
    subq   %r11, %r9        # r9 = best_sum - current_sum
    jg L4
    rrmovq %r11, %r10       # best_sum = current_sum
L4: # back to the loop
    irmovq $8, %rcx         # rcx = 8
    addq %rcx, %r8          # ptr++
    jmp    L1               # jump to beginning of loop

L5: # exits the loop

    rrmovq %r10, %rax       # return best_sum
    ret

.pos 0x2000
array:
    .quad 13
    .quad -3
    .quad -25
    .quad -20
    .quad -3
    .quad -16
    .quad -23
    .quad 18
    .quad 20
    .quad -7
    .quad 12
    .quad -5
    .quad -22
    .quad 15
    .quad -4
    .quad 7
arraySize:
 .quad 16

.pos 0x2500
resultStart:
    .quad 0
resultEnd:
    .quad 0
resultSum:
    .quad 0
.pos 0x4000
stack:
    .quad 0, 1000
stackEnd:
    .quad 0
